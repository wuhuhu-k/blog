(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{731:function(a,v,_){"use strict";_.r(v);var t=_(0),i=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"微前端架构适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端架构适用场景"}},[a._v("#")]),a._v(" 微前端架构适用场景")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.项目非常庞大，需要每个团队单独开发维护（解耦）")])]),a._v(" "),v("li",[v("p",[a._v("2.维护老项目，需要使用新的技术栈增加新功能（使用不同的技术栈）")])])]),a._v(" "),v("h2",{attrs:{id:"为什么不是-iframe"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是-iframe"}},[a._v("#")]),a._v(" 为什么不是 iframe？")]),a._v(" "),v("p",[a._v("因为 iframe 有以下几个问题")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.iframe 会阻塞主应用的渲染")])]),a._v(" "),v("li",[v("p",[a._v("2.iframe 的通信成本高")])]),a._v(" "),v("li",[v("p",[a._v("3.iframe 的样式隔离成本高,")])]),a._v(" "),v("li",[v("p",[a._v("4.url 不同步，页面刷新，url 状态丢失，浏览器前进后退没用")])])]),a._v(" "),v("h2",{attrs:{id:"微前端架构的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端架构的优缺点"}},[a._v("#")]),a._v(" 微前端架构的优缺点")]),a._v(" "),v("h3",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.独立开发，独立部署，独立运行")])]),a._v(" "),v("li",[v("p",[a._v("2.技术栈无关")])])]),a._v(" "),v("h3",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.主应用和子应用需要进行通信，需要约定通信方式")])]),a._v(" "),v("li",[v("p",[a._v("2.子应用之间需要进行通信，也需要约定通信方式")])]),a._v(" "),v("li",[v("p",[a._v("3.需要解决样式隔离的问题")])]),a._v(" "),v("li",[v("p",[a._v("4.需要解决路由问题")])]),a._v(" "),v("li",[v("p",[a._v("5.需要解决状态共享问题")])])]),a._v(" "),v("h2",{attrs:{id:"常用微前端框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用微前端框架"}},[a._v("#")]),a._v(" 常用微前端框架")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.single-spa")])]),a._v(" "),v("li",[v("p",[a._v("2.qiankun（阿里基于 single-spa 二次封装）")])]),a._v(" "),v("li",[v("p",[a._v("3.wujie")])]),a._v(" "),v("li",[v("p",[a._v("4.wabpack5 模块联邦")])])]),a._v(" "),v("h2",{attrs:{id:"微前端架构的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端架构的实现"}},[a._v("#")]),a._v(" 微前端架构的实现")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.路由劫持")])]),a._v(" "),v("li",[v("p",[a._v("2.状态管理")])]),a._v(" "),v("li",[v("p",[a._v("3.样式隔离")])]),a._v(" "),v("li",[v("p",[a._v("4.通信机制")])]),a._v(" "),v("li",[v("p",[a._v("5.沙箱机制")])])]),a._v(" "),v("h2",{attrs:{id:"qiankun-的运行原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#qiankun-的运行原理"}},[a._v("#")]),a._v(" qiankun 的运行原理")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.监听路由变化 hash 模式 window.onHashChange() history 模式 window.onPopState()")])]),a._v(" "),v("li",[v("p",[a._v("2.匹配子应用 根据监听路由的变化，拿到当前的路由地址，去注册的子应用列表中找到对应的子应用，找到对应的 activeRule")])]),a._v(" "),v("li",[v("p",[a._v("3.加载子应用 然后请求访问对应的 html 资源")])]),a._v(" "),v("li",[v("p",[a._v("4.渲染子应用 拿到对应的 html 资源后，将 html 资源放入注册时给定的容器中去，获取 html 中的 script 脚本，执行所有的脚本")])])]),a._v(" "),v("h2",{attrs:{id:"常见问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[a._v("#")]),a._v(" 常见问题")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("1.父子应用样式错乱\n原因，父子应用中使用相同的组件库，类名相同，导致了样式冲突\n解决，1.自定义命名空间 2.使用 CSS Modules 3.使用 BEM 命名规范，4.使用插件修改组件库样式前缀（postcss-prifix）,5.尽量少使用全局样式，多使用局部样式")])]),a._v(" "),v("li",[v("p",[a._v("2.子应用刷新后，页面空白")])])])])}),[],!1,null,null,null);v.default=i.exports}}]);